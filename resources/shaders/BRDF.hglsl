/*
    BRDF.hglsl
*/

#include <Material.hglsl>

#define PI    3.1415926f
#define InvPI 0.318309886f

layout(std140) uniform CookTorranceMaterialUniformBlock
{
    CookTorranceMaterial m_cookTorranceMaterial;
};

vec3 calCookTorranceDiffuse(
    const vec3 albedo)
{
    vec3 diffuseComponent;
    
    diffuseComponent = albedo * InvPI;
    
    return diffuseComponent;
}

float cookTorranceDistribution(
    const vec3  N,
    const vec3  H,
    const float alpha) ///< Material roughness
{
    float distributionCoefficient = 0.0f;
    
    float alpha2 = alpha * alpha;
    
    float NoH  = clamp(dot(N, H), 0.0f, 1.0f);
    
    float NoH2 = NoH * NoH;
    
    float k  = NoH2 * (alpha2 - 1) + 1;
    float k2 = k * k;
    
    distributionCoefficient = ((alpha2) / (PI * k2));
    
    return distributionCoefficient;
}

float cookTorranceGeometry(
    const float NoX,   ///< NoL or NoV
    const float alpha) ///< Material roughness
{
    float geometryCoefficient;
    
    float k = (alpha + 1) * (alpha + 1) * 0.125f;
    
    geometryCoefficient = ((NoX) / (NoX * (1 - k) + k));
    
    return geometryCoefficient;
}

float schlickFresnel(
    const vec3  V,
    const vec3  H,
    const float fresnel)
{
    float fresnelCoefficient = 1.0f;
    
    float F0 = fresnel;
    
    float VoH = clamp(dot(V, H), 0.0f, 1.0f);
    float exponent = (-5.55473f * VoH - 6.98316f) * VoH;
    
    fresnelCoefficient = F0 + (1 - F0) * pow(2.0f, exponent);
    
    return fresnelCoefficient;
}

vec3 calCookTorranceSpecular(
    const vec3                 V,
    const vec3                 N,
    const vec3                 L,
    const float                NoL,
    const CookTorranceMaterial material)
{
    float specularComponent = 0.0f;
    
    float NoV = clamp(dot(N, V), 0.0f, 1.0f);
    
    if (NoL > 0.0f && NoV > 0.0f)
    {
        vec3 halfVector = normalize(V + L);
    
        float D = cookTorranceDistribution(N, halfVector, material.roughness);
        float G = cookTorranceGeometry(NoL, material.roughness) * cookTorranceGeometry(NoV,  material.roughness);
        float F = schlickFresnel(V, halfVector, material.fresnel);
        
        specularComponent = (D * G * F) / (4 * NoL * NoV);
    }
    
    return vec3(specularComponent);
}

vec3 calCookTorranceBRDF(
    const vec3                 V,
    const vec3                 N,
    const vec3                 L,
    const float                NoL,
    const CookTorranceMaterial material,
    const float                shadowSpecularAttenuation)
{
    vec3 fd = calCookTorranceDiffuse(material.albedo);
    vec3 fs = shadowSpecularAttenuation * calCookTorranceSpecular(V, N, L, NoL, material);

    vec3 brdf = clamp((((1.0f - material.metallic) * fd) +
                        (material.metallic) * fs), 0.0f, 1.0f);
    
    brdf = fs;
    
    return brdf;
}
    